#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require

#include "common/limits.glsl"
#include "common/rt_types.glsl"

// --------------------- INPUT --------------------- //

struct CameraBuffer {
  mat4 view_proj;
  mat4 view_inverse;
  mat4 proj_inverse;
};

layout (set = 0, binding = 0, std140) uniform CameraUniformBuffer {
  CameraBuffer data[1024];
} camera_buffer;
layout (set = 3, binding = 0, rgba32f) uniform image2D storage_image[];
layout (set = 4, binding = 0) uniform accelerationStructureEXT top_level_as[];

layout (push_constant) uniform Constants {
  vec4 color;
  mat4 mvp;
  uint material_index;
  uint rt_storage_index;
  uint camera_buffer_index;
  uint padding;
} push_constant;

// ------------------------------------------------- //

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

void main() {
  const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = in_uv * 2.0 - 1.0;

  readonly CameraBuffer camera_data = camera_buffer.data[push_constant.camera_buffer_index];

  vec4 origin = camera_data.view_inverse * vec4(0, 0, 0, 1);
  vec4 target = camera_data.proj_inverse * vec4(d.x, -d.y, 1, 1);
  vec4 direction = camera_data.view_inverse * vec4(normalize(target.xyz), 0);

  uint ray_flags = gl_RayFlagsOpaqueEXT;
  float t_min = 0.001;
  float t_max = 10000.0;

  vec3 color = vec3(0.0);

  for (int i = 0; i < MAX_RAY_RECURSION; i++) {
    traceRayEXT(top_level_as[0], ray_flags, 0xFF, 0, 0, 0, origin.xyz, t_min, direction.xyz, t_max, 0);
    const vec3 hit_color = ray_payload.color;

    if (ray_payload.distance < 0.0) {
      color += hit_color;
      break;
    } else {
      const vec4 hit_pos = origin + direction * ray_payload.distance;
      origin.xyz = hit_pos.xyz + ray_payload.normal * 0.001;
      direction.xyz = reflect(direction.xyz, ray_payload.normal);
      color += hit_color * (1.0 / (float(i) + 1.0));
    }
  }

  imageStore(storage_image[push_constant.rt_storage_index], ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
